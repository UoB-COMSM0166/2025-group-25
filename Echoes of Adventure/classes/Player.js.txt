// =========================
// ğŸ® ç©å®¶ç±» (æœ€ç»ˆä¼˜åŒ–ç‰ˆ)
// =========================

class Player {
  constructor(startPos) {
    this.position = startPos.copy();
    this.velocity = createVector(0, 0);
    this.width = 60;
    this.height = 60;
    this.speed = 5;
    this.jumpForce = 15;
    this.lives = 3;
    this.coins = 0;
    this.invincible = false;
    this.hasDoubleJump = true;
    this.hasDash = false;       
    this.jumps = 0;
    this.invincibleTimer = 0;
    this.damageCooldown = 0;
    this.isAttacking = false;
    this.attackCooldown = 0;
    this.attackDuration = 10;
    this.facingDirection = "right"; 
    this.state = "idle"; 
    this.isOnGround = false;  
    this.hasTeleport = false;

    // **å†²åˆºç›¸å…³**
    this.isDashing = false;  
    this.dashCooldown = 0;   
    this.dashDuration = 15;  
    this.dashSpeed = 12;     
    this.dashTimeLeft = 0;  

    // **åŠ¨ç”»ç›¸å…³**
    this.frameIndex = 0;
    this.frameDelay = 6;
    this.frameCounter = 0;
    this.loadAnimationFrames();
  }

  /** ğŸ”„ ç»Ÿä¸€åŠ è½½åŠ¨ç”»å¸§ */
  loadAnimationFrames() {
    this.animations = {
      idle: this.loadFrames("player-idle", 4),
      run: this.loadFrames("player-run", 6),
      jump: [loadImage("assets/player-jump-1.png")], // åªæœ‰1å¸§
      attack: this.loadFrames("player-attack", 2),
      dash:[loadImage("assets/player-dash.png")]
    };
  }

  /** ğŸ“œ åŠ è½½åŠ¨ç”»å¸§çš„è¾…åŠ©å‡½æ•° */
  loadFrames(baseName, count) {
    return Array.from({ length: count }, (_, i) => 
      loadImage(`assets/${baseName}-${i + 1}.png`)
    );
  }

  /** ğŸš€ å¤„ç†è§’è‰²ç§»åŠ¨ */
  handleMovement() {
    if (this.isDashing) return; // **æ­£åœ¨å†²åˆºæ—¶ä¸è¿›è¡Œæ™®é€šç§»åŠ¨**

    let horiz = 0;
    if (keyIsDown(LEFT_ARROW)) {
      horiz -= this.speed;
      this.facingDirection = "left";
    }
    if (keyIsDown(RIGHT_ARROW)) {
      horiz += this.speed;
      this.facingDirection = "right";
    }

    this.position.x += horiz;

    if (level) {
      let levelWidth = level.portalPosition.x + 200;
      this.position.x = constrain(this.position.x, 0, levelWidth - this.width);
    }

    this.velocity.y += 0.8;
    this.position.y += this.velocity.y;

    if (this.position.y >= height - this.height) {
      this.position.y = height - this.height;
      this.velocity.y = 0;
      this.jumps = 0;
      this.isJumpKeyReleased = true;
    }
  }

  /** ğŸ® å¤„ç†è·³è·ƒ (åœ¨ `keyPressed()` é‡Œè°ƒç”¨) */
  jump() {
    if (this.isJumpKeyReleased && this.jumps < (this.hasDoubleJump ? 2 : 1)) {
      this.velocity.y = -this.jumpForce;
      this.jumps++;
      this.isJumpKeyReleased = true; // **å…è®¸é‡å¤è·³è·ƒ**
    }
  }

  /** ğŸš€ å¤„ç†å†²åˆº */
  dash() {
    if (!this.hasDash || this.isDashing || this.dashCooldown > 0) return;

    this.isDashing = true;
    this.dashTimeLeft = this.dashDuration;
    this.dashCooldown = 60; 

    // **è®¡ç®—å†²åˆºæ–¹å‘**
    let dashAngle;
    if (keyIsDown(UP_ARROW)) { 
      dashAngle = this.facingDirection === "right" ? -PI / 3 : -2 * PI / 3; 
    } else {
      dashAngle = this.facingDirection === "right" ? -PI / 6 : -5 * PI / 6; 
    }

    this.velocity.x = this.dashSpeed * cos(dashAngle);
    this.velocity.y = this.dashSpeed * sin(dashAngle);
  }
  /*
  teleport() {
    if (this.currentItem === "Teleport Scroll") {
      let newX = this.position.x + 200;
      
      // **æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦å®‰å…¨**
      if (this.isSafePosition(newX, this.position.y)) {
        this.position.x = newX;
        console.log("âœ¨ Teleported to safe position:", this.position);
      } else {
        console.log("âš ï¸ Unsafe teleport, canceled.");
      }

      this.currentItem = null;  // **ä½¿ç”¨åæ¶ˆè€—**
    }
   
  }
*/
  teleport() {
    if (!this.hasTeleport) return;

    let teleportDistance = 200;
    let newX = this.position.x + teleportDistance;

    let safe = true;
    for (let enemy of level.enemies) {
      if (abs(enemy.position.x - newX) < 50) {
        safe = false;
        break;
      }
    }

    if (safe) {
      console.log(`ğŸ”¹ ä¼ é€å‰ä½ç½®: ${this.position.x}`);
      this.position.x = newX;
      console.log(`âœ… ä¼ é€åä½ç½®: ${this.position.x}`);
      this.hasTeleport = false;
      player.currentItem = "NONE"; // **ç”¨å®Œåæ¸…ç©º ITEM**
    } else {
      console.log("âŒ ä¼ é€å¤±è´¥ï¼Œç›®æ ‡ç‚¹æœ‰æ•Œäººï¼");
    }
  }


  /** æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦å®‰å…¨ */
  isSafePosition(x, y) {
    for (let plat of level.platforms) {
      if (
        x + this.width > plat.position.x &&
        x < plat.position.x + plat.width &&
        y + this.height > plat.position.y &&
        y < plat.position.y + plat.height
      ) {
        return true;  // **å®‰å…¨ï¼šæœ‰å¹³å°å¯ç«™ç«‹**
      }
    }
    return false;  // **å±é™©ï¼šæ— æ”¯æ’‘ç‚¹ï¼Œå¯èƒ½æ‰ä¸‹å»**
  }


   /** ğŸ® æ™®é€šæ”»å‡» */
   attack() {
    if (this.isAttacking || this.attackCooldown > 0) return;
  
    this.isAttacking = true;
    this.state = "attack";
    this.frameIndex = 0;
    this.frameCounter = 0;
  
    setTimeout(() => {
      this.isAttacking = false;
      this.attackCooldown = 10;
      this.state = "idle";
    }, 400);
  
    let attackX = this.facingDirection === "right"
      ? this.position.x + this.width
      : this.position.x - 20;
    let attackY = this.position.y + this.height / 2;
  
    // **è¿œç¨‹æ”»å‡»é€»è¾‘**
    if (this.currentItem === "Flame Element") {
      let fireProj = new FlameProjectile(attackX, attackY, this.facingDirection);
      projectiles.push(fireProj);
    } else if (this.currentItem === "Freeze Element") {
      let freezeProj = new FreezeProjectile(attackX, attackY, this.facingDirection);
      projectiles.push(freezeProj);
    } else if (this.currentItem === "Thunder Element") {
      let thunderProj = new ThunderProjectile(attackX, attackY,this.facingDirection);
      projectiles.push(thunderProj);
    } else {
      // **é»˜è®¤è¿‘æˆ˜æ”»å‡»**
      let attackRange = 35;
      for (let i = level.enemies.length - 1; i >= 0; i--) {
        let enemy = level.enemies[i];
        if (
          enemy.position.x > attackX - attackRange &&
          enemy.position.x < attackX + attackRange &&
          abs(enemy.position.y - this.position.y) < 40
        ) {
          level.enemies.splice(i, 1);
          console.log("Hit enemy!");
        }
      }
    }
  }

  


  /** ğŸ® ç›‘å¬é”®ç›˜æŒ‰ä¸‹ */
  keyPressed() {
    if (key === " ") {
      this.jump();
    }
    if (key === "Z" || key === "z") {
      this.attack();
    }
    if (key === "X" || key === "x") this.dash();
    
    /*if (key === "T" || key === "t") {
      player.teleport();
    }*/
    if (this.hasTeleport && (key === "T" || key === "t")) {
      this.teleport();
    }
    
  }

  /** ğŸ® ç›‘å¬é”®ç›˜é‡Šæ”¾ */
  /*
  keyReleased() {
    if (key === " ") {
      this.isJumpKeyReleased = true; // **æ¾å¼€ç©ºæ ¼åï¼Œå…è®¸å†æ¬¡è·³è·ƒ**
    }
  }
*/
  /** âš¡ å¤„ç†ç¢°æ’æ£€æµ‹ */
  handleCollisions() {
    if (!level) return;
    let { platforms, enemies } = level;

    for (let plat of platforms) {
      if (this.velocity.y >= 0 && collides(this.position.x, this.position.y, this.width, this.height,
                                           plat.position.x, plat.position.y, plat.width, plat.height)) {
        if (this.position.y + this.height - this.velocity.y <= plat.position.y + 5) {
          this.position.y = plat.position.y - this.height;
          this.velocity.y = 0;
          this.jumps = 0;
          this.isJumpKeyReleased = true;
        }
      }
    }

    for (let enemy of enemies) {
      if (!this.invincible && collides(this.position.x, this.position.y, this.width, this.height,
                                       enemy.position.x, enemy.position.y, enemy.width, enemy.height)) {
        this.takeDamage(1);
      }
    }
  }

  /** ğŸ¥ è®¡ç®—å½“å‰åŠ¨ç”»çŠ¶æ€å¹¶é‡ç½® `frameIndex` */
  updateAnimationState() {
    let previousState = this.state; // è®°å½•ä¹‹å‰çš„çŠ¶æ€
    let previousDirection = this.facingDirection; // è®°å½•ä¹‹å‰çš„æ–¹å‘

    if (this.velocity.y < 0) {
      this.state = "jump";  // **è·³è·ƒçŠ¶æ€**
    } else if (this.isDashing) {
      this.state = "dash";  // **å†²åˆºçŠ¶æ€**
    } else if (keyIsDown(LEFT_ARROW) || keyIsDown(RIGHT_ARROW)) {
      this.state = "run";  // **è·‘æ­¥çŠ¶æ€**
    }else if (this.isAttacking) {// **æ”»å‡»çŠ¶æ€**
      this.state = "attack"; 
    }else {
      this.state = "idle"; // **é™æ­¢çŠ¶æ€**
    }

    // **å¦‚æœçŠ¶æ€æˆ–æ–¹å‘å‘ç”Ÿå˜åŒ–ï¼Œé‡ç½® `frameIndex`**
    if (this.state !== previousState || this.facingDirection !== previousDirection) {
        this.frameIndex = 0;
        this.frameCounter = 0;
    }
  }

  /** ğŸ¥ è·å–å½“å‰åŠ¨ç”»å¸§ */
  getCurrentAnimation() {
    return this.animations[this.state];
  }

  /** ğŸ›¡ï¸ å¤„ç†ä¼¤å®³ */
  takeDamage(amount) {
    if (this.invincible || this.lives <= 0) return;

    this.lives -= amount;
    this.lives = max(0, this.lives);
    this.invincible = true;
    this.invincibleTimer = 2; // 2ç§’æ— æ•Œ
    damageFlashAlpha = 150;
    console.log(`Player took damage! Lives left: ${this.lives}`);

    if (this.lives <= 0) {
      this.die();
    }
  }

  /** ğŸ® ç©å®¶æ­»äº¡ */
  die() {
    console.log("Player has died!");
    if (typeof resetGame === "function") {
      resetGame();
    } else {
      console.error("No resetGame() function found!");
    }
  }

  update() {
    // **å—ä¼¤å†·å´**
    if (this.damageCooldown > 0) this.damageCooldown -= deltaTime / 1000;
    
    // **æ— æ•ŒçŠ¶æ€**
    if (this.invincibleTimer > 0) {
        this.invincible = true;
        this.invincibleTimer -= deltaTime / 1000;
    } else {
        this.invincible = false;
    }
    if (mode === "invincible") {
        this.invincible = true;
    }

    // **Dash å†²åˆºé€»è¾‘**
    if (this.isDashing) {
      this.dashTimeLeft--;
      this.position.x += this.velocity.x;
      this.position.y += this.velocity.y;

      if (this.dashTimeLeft <= 0) {
          this.isDashing = false;
          this.dashCooldown = 30;
      }
  } else {
        // **æ™®é€šç§»åŠ¨å’Œç¢°æ’**
        this.handleMovement();
        this.handleCollisions();
    }

    // **Dash å†·å´**
    if (this.dashCooldown > 0) {
        this.dashCooldown--;
    }

    // **æ›´æ–°åŠ¨ç”»**
    this.updateAnimationState();

    this.frameCounter++;
    if (this.frameCounter >= this.frameDelay) {
        let currentAnimation = this.getCurrentAnimation();
        if (currentAnimation.length > 0) {
            this.frameIndex = (this.frameIndex + 1) % currentAnimation.length;
        } else {
            this.frameIndex = 0;
        }
        this.frameCounter = 0;
    }

    // **æ”»å‡»å†·å´**
    if (this.attackCooldown > 0) {
        this.attackCooldown--;
    }
}


  draw() {
    push();
    translate(this.position.x + this.width / 2, this.position.y + this.height / 2);

    // **å¦‚æœé¢æœå·¦ï¼Œç¿»è½¬å›¾åƒ**
    if (this.facingDirection === "left") {
        scale(-1, 1);
    }

    let currentFrame = this.getCurrentAnimation()[this.frameIndex];
    image(currentFrame, -this.width / 2, -this.height / 2, this.width, this.height);

    pop();
  }



  /** ğŸ¯ ç¢°æ’æ£€æµ‹ */
  collidesWith(obj) {
    return collides(this.position.x, this.position.y, this.width, this.height,
                    obj.position.x, obj.position.y, obj.width, obj.height);
  }
}
